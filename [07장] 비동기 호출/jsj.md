# 7장 (비동기 호출)

## 7.1 API 요청

- 컴포넌트 내에 깊게 자리 잡은 비동기 호출 코드는 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움이 발생한다.
- 비동기 호출 코드는 컴포넌트 영역에서 분리되어 다른 영역(서비스 레이어)에서 처리되어야 한다.
- fetch 보다 Axios 라이브러리를 사용하여 기능을 사용한다.

> ❓ 비동기 호출 인터셉터란?
HTTP 요청 처리 중에 발생하는 이벤트를 가로채고 처리하는 객체. 기존 컨트롤러의 로직을 수정하지 않고도 사전, 사후에 제어가 가능함. (세션을 통한 인증 구현이나 응답을 가로채어 데이터를 추가한 후 보내기 등)
> 
- 인터셉터 기능을 사용하여 requester에 따라 비동기 호출 내용을 추가해서 처리할 수 있음 (헤더 관리나 에러 처리 등)
    
    ```tsx
    const apiRequester: AxiosInstance = axios.create({
    	baseURL:"https:....",
    	timeout:5000,
    	});
    
    apiRequester.interceptors.request.use(setRequestDefaultHeader);
    ...
    ```
    
- 요청 옵션에 따라 다른 인터셉터를 만드려고 빌더 패턴을 추가하여 클래스 형태로 구성하기도 함

> ❓ 빌더 패턴이란?
객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴.
주로 복잡한 객체의 생성을 단순화 하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공함.
> 

```tsx
class APIBuilder {
	//요소 정의
	private _instance: API;
	constructor(method: HTTPMethod, url:string, data?:unknown){
		this._instance = new API(method, url);
		this._instance.baseURL = apiHost;
		...
	}
	//요소를 설정하는 builder 메소드들
	baseURL(value:string): APIBuilder{
		this._instance.baseURL = value;
		return this;
	}
	params(value:HTTPParams): APIBuilder{
		this._instance.params = value;
		return this;
	}
	...
	build():API{
		return this._instance;
	}
}
//이런 APIBuilder를 사용하는 코드는 다음과 같다.
const api = APIBuilder.get("/apis/web")
.baseURL("apis/test")
.params({name, size})
.build(); 
```

- 이렇게 빌더 패턴을 사용할 경우 보일러 플레이트 코드가 많지만, 옵션이 다양한 경우에 인터셉터를 설정값에 따라 적용하고, 인터셉터를 선택적으로 사용할 수 있다.

> ❓ 보일러 플레이트 코드
어떤 기능을 사용할 때 반복적으로 사용되는 기본적인 코드. 위에서는 기본적인 설정이나  API 호출 단에서의 인터셉터 등을 설정하는 부분 등이다.
> 
- API 요청이나 응답 값 중 해당 값에 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향을 주지 않는 경우에는 unknown 타입을 사용하여 알 수 없는 값임을 표현한다.
- 뷰 모델 사용의 이점
    - API 응답이 바뀌어도 응답이 깨지지 않게 개발할 수 있음
    - 기존에 없던 새로운 도메인 개념을 넣 때 백엔드나 UI에서 로직 추가 없이 간편하게 새로운 필드를 뷰 모델에 추가할 수 있음
- 뷰 모델 사용의 단점
    - 인터페이스 같은 추상화 레이어의 추가로 코드가 복잡해지고 레이어를 관리, 개발하는데 돈이 듬
    - 새로운 필드를 추가하여 사용할 때 서버와 클라 간의 실제 사용하는 도메인이 달라서 의사소통 문제가 생길 수 있다.
- superstruct 라이브러리
    - 인터페이스 정의와 자바 스크립트 데이터의 유효성 검사를 쉽게 할 수 있음
    - 런타임에서의 데이터 유효성 검사를 통해 자세한 런타임 에러 관측 가능
    - 런타임 타입 검증을 위해 보통 사용됨

## 7.2 API 상태 관리하기

- 상태 관리 라이브러리의 비동기 함수들은 service 코드를 사용하여 비동기 상태를 변화 시킬 수 있는 함수를 제공한다. 컴포넌트는 이러한 함수를 사용하여 상태를 구독하며, 상태가 변경될 때 컴포넌트를 다시 렌더링 한다.
- 상태 관리 라이브러리의 경우 비동기 처리 함수를 호출하기 위해 액션이 추가될때 마다 관련된 스토어나 상태가 늘어나게 된다.. 이로 인해 전역 상태 관리자가 모든 비동기 상태에 접근하고 변경할 수 있게 되는 문제가 발생한다. 이로 인해 쓸데 없는 비동기 통신이 발생하거나 의도치 않은 상태 변경이 일어날 수 있다.
- 훅을 사용한 방법은 상태 변경 라이브러리보다 더 간단하다. 훅은 캐시를 통해 비동기 함수를 호출하고 의도치 않은 상태 변경 또한 방지한다.
- 비동기 함수들을 사용할 때는 상태 관리보다 훅 (react-query등)을 사용하여 기능을 구현해보자!
- 컴포넌트가 반드시 최신 상태를 표현하려면 폴링이나 웹 소켓 등의 방법을 이용해야 한다.

> ❓폴링이란?
클라이언트가 주기적으로 서버에 요청을 보내 데이터를 업데이트하는 것. 일정한 시간 간격으로 서버에 요청을 보내고, 서버는 해당 요청에 대해 최신 상태의 데이터를 응답으로 보내주는 방식을 말한다.
> 
- 전역 상태 관리 라이브러리를 react-query로 변경하고자 하는 시도가 늘고 있다. 상태 관리 라이브러리는 비동기로 상태를 변경하는 코드가 점점 추가되면 전역 상태 관리 스토어가 비대해지기 때문이다. 단순히 액션이 증가하는 것뿐만 아니라 전역 상태 자체도 복잡해진다.

(그럼 전역 상태 관리로 비동기 하는 것의 이점이 뭘까?)

## 7.3 API 에러 핸들링

- 타입 가드 활용하기
    - Axios의 경우 isAxiosError라는 타입 가드를 제공하고 있다. 이를 통해 서버 에러임을 명확하게 표시하고 서버에서 내려주는 에러 응답 객체에 대해서도 구체적으로 정의하여 에러 객체가 어떤 속성을 가졌는지 파악할 수 있다.
    - 이를 통해 다음과 같이 타입 가드를 명시적으로 작성하여 서버 에러인지 알 수 있다.
        
        ```tsx
        interface ErrorResponse {
        	status: string;
        	serverDateTime: string;
        	errorCode: string;
        	errorMessage: string;
        }
        //ErrorResponse 인터페이스를 사용하여 처리해야 할 Axios 에러 형태는 AxiosError<ErrorResponse>로 표현할 수 있다.
        //그리고 아래와 같이 타입 가드를 명시적으로 작성할 수 있다.
        function isServerError(error: unknown): error is AxiosError<errorResponse> {
        	return axios.isAxiosError(error);
        }
        //이를 바탕으로
        const onClickDeleteHistoryButton = async (id: string) => {
        try{
        	await axios.post("https://.., { id }");
        	alert(" 주문 내역이 삭제되었습니다 .");
        } catch (error: unknown) {
        if (isServerError(e) && e.response && e.response.data.errorMessage) {
        // 서버 에러일 때의 처리임을 명시적으로 알 수 있다
        		setErrorMessage(e.response.data.errorMessage);
        	return;
        	}
        		setErrorMessage(" 일시적인 에러가 발생했습니다. 잠시 후 다시 시도해주세요 ");
        	}
        };
        ```
        
- 에러 서브 클래싱하기
    - 단순 서버에러 외에도 발생하는 다양한 에러를 표시하기 위해 서브 클래싱을 활용할 수 있다.
    - 서버에서 전달된 에러 메세지를 보고 개발자 입장에서는 사용자 로그인 정보가 만료되었는지 , 타임아웃이 발생한 건지 혹은 데이터를 잘못 전달한 것인지를 구분할 수 없다.
    - 이때 서브 클래싱을 통해 코드상에서 어떤 에러인지 바로 확인할 수 있고 에러 인스턴스가 무엇인지에 따라 에러 처리 방식을 다르게 구현할 수 있다.
    - (서브 클래싱 예제 코드)
- 인터셉터를 활용한 에러 처리
    - Axios 같은 fetching 라이브러리는 인터셉터 기능을 제공하며 이를 사용하여 HTTP 에러에 일관된 로직을 활용할 수 있다.
    - (예제 코드)
- 에러 바운더리를 활용한 에러 처리
    - 리액트 컴포넌트 트리에서 에러가 발생할 때 공통으로 에러를 처리하는 리액트 컴포넌트이다.
    - 에러 바운더리를 사용하면 리액트 컴포넌트 트리 하위에 있는 컴포넌트에서 발생한 에러를 캐치하고, 해당 에러를 가장 가까운 부모 에러 바운더리에서 처리하게 할 수 있다.
    - (예제 코드)
- 상태 관리 라이브러리에서의 에러 처리
    - 에러를 상태로 처리하며 상태를 관리하지 않고 바로 처리할 수 있는 경우 (401, 403)는 바로 처리하고 그렇지 않으면 reject로 넘겨서 처리한다.
- react-query에서의 처리
    - fetching 라이브러리들은 요청에 대한 상태를 반환해주기 때문에 요청 상태를 확인하기 쉽다.
- 그 밖의 에러 처리
    - 커스텀 에러의 경우 조건문 등으로 status를 비교하여 커스텀 에러를 처리해보자.

## 7.4 API 모킹

- 가짜 모듈을 통해 서버가 아직 개발이 되어있지 않더라도 진행할 수 있다.
- JSON 파일 만들기
    - 간단한 조회의 경우 json 파일을 만들거나 json 형식의 정보를 저장하고 export 해주는 방식으로 처리하자.
- NextApiHandler 활용하기
    - next.js의 경우 NextApiHandler를 활용하여 하나의 파일 안에 하나의 핸들러를 default export로 구현해야 하며 파일의 경로가 요청 경로가 된다.
    - 핸들러를 정의할 때 응답하고자 하는 값과 요청에 대한 응답을 정의하여 로직을 추가하자