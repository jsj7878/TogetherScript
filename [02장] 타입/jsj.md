# 2장 (타입)

## 2.1 타입이란

- 변수란? → 프로그래밍 언어에서 값을 저장할 수 있는 공간(컴퓨터 메모리에 저장) 이자 값을 가리키는 이름
- 메모리 공간의 값의 크기를 알아야 불러서 읽어올 수 있기 때문에 타입(자료형)이 꼭 필요함
- java script의 기본 데이터 타입
    
    → boolean, null, undefined, number, bigint, string, symbol
    
- 프로그래밍에서의 타입은 값이 가질 수 있는 유효한 범위의 집합을 말함.  이를 통해 어떤 일을 할 수 있는지 알 수 있음

| 비교 | 정적 타입 | 동적 타입 |
| --- | --- | --- |
| 타입 결정 시점 | 컴파일타임 | 런타임 |
| 언어 | c, java, ts | python, js |
| 특징 | - 번거로움
- 컴파일타임에 타입 에러 발견 가능
- 안정성 보장 | - 개발시 편함
- 타입 에러 발견 어려움
 |
- ❓ 컴파일과 런타임
    
    컴파일 타임 → 기계가 소스코드를 기계어로 변환하는 시점
    런타임 → 변환된 파일이 메모리 적재되어 실행되는 시점
    

- 암묵적 타입 변환 → 타입을 명시하지 않아도 컴파일러나 엔진 등에 의해 런타임에 타입이 자동으로 변경됨
- 암묵적 타입 변환 여부에 따라 타입 시스템을 강타입, 약타입으로 분류함
    - 강타입 → 서로 다른 타입을 갖는 값끼리 연산 시도 시 컴파일러, 인터프리터에서 에러 발생
    - 약타입 → 컴파일러, 인터프리터에서 내부적으로 판단해서 특정 값의 타입을 변환하여 연산 수행
- 언어가 알아서 타입을 변환해주어 연산을 진행하는 것은 편리하지만 예기치 못한 에러가 발생할 수 있다!
- 프로그램을 안전하게 만든다는 것은 타입을 통해 프로그램이 유효하지 않은 작업을 수행하지 않도록 방지하는 것이다.

<aside>
💡

1. 타입은 개발자가 변수 값을 저장하고 사용하기 위한 분류이다.
2. 자바 스크립트는 동적 타입이자 약타입 언어인데 이에 따른 불편함과 안정성을 보완하기 위해 타입 스크립트가 등장했다
3. 타입 스크립트는 컴파일 타임에 검사를 실행하지만 필요에 따라 타입 선언의 생략을 허용 하기도 하는데 이는 자바 스크립트 기반의 언어이고 타입 관련 문제를 고치고자 등장 했기에 두가지 타입 시스템의 영향을 받은 것이다. 
</aside>

## 2.2 타입 스크립트의 타입 시스템

- 타입 애너테이션 
→ 변수, 상수, 함수의 인자와 반환 값에 타입을 명시적으로 선언하여 어떤 타입의 값이 저장될 것인지를 컴파일러에 알려주는 문법
- 자바 등에서는 타입을 변수보다 먼저 명시해줘야 하는데 타입 스크립트는 변수 뒤에 붙여준다.
- 일반적으로 타입을 사용하는 여러 프로그래밍 언어에서는 값들이 하나의 구체적인 타입을 가지고 있음.
이름으로 타입이 구분되며 컴파일 타임 이후에도 남아있는데 이를 “명목적으로 구체화한 타입 시스템”이라 함
- 구조적 타이핑 
→ 이름으로 타입을 구분하는 타입 언어들과 달리 구조로 타입을 구분함 
(타입을 값의 집합이라 생각하자!)
- 구조적 서브 타이핑 → 객체가 가지고 있는 속성을 바탕으로 타입을 구분하는 것. 이름이 다르더라도 가진 속성이 동일하면 서로 호환 가능하게 봄.  따라서 특정 값이 여러 타입을 동시에 가질 수 있게 됨.

```tsx
type stringOrNumber = string | number;
```

- ❓(구조로 타입 구분하고 속성으로 타입 구분하는 것까지는 알겠는데 위의 코드는 머임 대체? 얘는 무슨 속성이길래 저 2개를 동시에 가질 수 있는거지)
    
    위의 코드처럼 여러 타입을 가지게 해주는 개념은 유니언 타입임. 지금 처럼 단순한 경우는 컴파일러 등을 통해 이 타입을 가진 변수가 어떤 타입을 가져야 되는지 판단해줌. 하지만 객체나 복잡한 구조를 가진 경우 구조적 서브 타이핑 개념을 통해 유니언 타입을 지원해줌
    

- 명목적 타이핑의 경우 이름이 다르면 구조가 같더라도 아예 다른 타입으로 취급함. 의도한 타입이 아니면 변수에 타입을 명시하는 과정에서 에러를 내고, 객체끼리 속성이 서로 호환되지 않도록 하여 안전성을 추구함.
- 타입 스크립트가 구조적 타이핑을 채택한 이유 
→ 자바 스크립트 기반의 언어이고 자바 스크립트는 덕 타이핑 기반의 언어임
- ❓ 덕 타이핑 (구조적 서브 타이핑)
    
    객체의 프로퍼티를 기반으로 사용처에서 사용함에 문제가 없다면 타입 호환을 허용하는 방식.
    

- 구조적 타이핑을 통해 객체나 함수가 가진 구조적 특징을 기반으로 타이핑이 가능하여 편리성을 높임
(당장 사용에 문제가 없고 이 객체를 통해 모든 메소드가 실행 가능하다면 그냥 사용한다는 것)
- 덕 타이핑은 런타임에 타입을 검사하지만 구조적 타입은 컴파일타임에 타입을 체크함
- 구조적 타이핑으로 인해 추가 속성을 가진 객체가 할당되게 되면 에러를 발생시킬 수 있기 때문에 타입 스크립트는 유니온 등을 도입하여 해결함
- 점진적 타입 
→ 컴파일 타임에 검사를 실행하지만 필요에 따라 타입 선언의 생략을 허용하는 것
- 타입 스크립트는 동적 타입 언어인 자바 스크립트 기반으로 만들어졌기 때문에 기반은 동적 이지만 자바 스크립트의 타입 시스템을 보완하기 위해 정적 타입 검사를 지원한다. 이로 인해 타입 스크립트는 점진적 타입 언어라고 불린다.
- 자바 스크립트에서 타입 스크립트로는 호환이 가능하지만 타입 스크립트에서 자바 스크립트로는 변환이 안될 수 있다. (타입 명시하는 문법이 있는데 자바 스크립트에서는 없기 때문)
- 값 
→ 프로그램이 처리하기 위해 메모리에 저장하는 모든 데이터. 프로그램에서 조작하고 다룰 수 있는 표현이자 다양한 형태의 데이터
- 타입 스크립트는 자바 스크립트 기반이기 때문에 변수 말고도 객체, 함수 등도 모두 값으로 변환하여 생각 할 수 있다.

```tsx
const func = function (){
	console.log("함수도 값이라니!")
}
```

- 이에 따라 타입 스크립트는 변수 등의 뒤에 :type 형태로 타입을 명시 할 수 있고 type, interface 키워드로 커스텀 타입을 정의 할 수도 있다.
- 값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있다.
이는 타입 스크립트가 type으로 선언한 내용은 자바 스크립트 런타임에서 제거되기 때문이다.
- 타입 스크립트는 개발자가 작성한 코드 문맥을 파악하여 스스로 값 또는 타입으로 해석한다. 값이 사용되는 위치와 타입이 사용 되는 위치가 다르기 때문에 추론이 가능한 것이다.
- ❓(하지만 이로 인해 문제가 생길 수도 있다.)
    
    ```tsx
    //js에서의 구조분해 할당
    function email({ person, subject, body})
    
    //ts에서의 구조분해 할당 (생각)
    function email({person: Person, subject: string, body:string})
    //하지만 이는 에러를 발생시킨다. 
    //{person: Person, subject: string, body:string} 구문 자체를 값으로 판단하기 때문
    
    //따라서 ts에서의 구조분해 할당은 다음과 같이 한다.
    function email({person, subject, body}:{person:Person, subject:string, body: string})
    
    ```
    

- enum과 class의 경우 타입, 값 둘다 로 해석된다. 이는 둘다 런타임에 객체로 변환되는 값이기 때문이다.
- 타입 스크립트에서 자바 스크립트의 키워드가 해석되는 방식
    
    
    | 키워드 | 값 | 타입 |
    | --- | --- | --- |
    | class | Y | Y |
    | enum | Y | Y |
    | const, let, var | Y | N |
    | function | Y | N |
    | namespace | Y | N |
    | interface | N | Y |
    | type | N | Y |
- 타입 스크립트에서 타입 확인시 typeof 연산자를 사용. 
instanceof 
→ 프로토타입 속성이 존재하는지 확인하는 것
- typeof 
→ 타입 확인시 사용함
→ boolean, null, undefined, number, bigint, string, symbol, function, object객체, 호스트객체 반환

<aside>
💡

1. 타입 스크립트는 구조로 타입을 구분하며 구조의 속성을 통해 같은지 판별하고 타입을 분류함
2. 타입 스크립트는 점진적 타입의 언어임
3. 타입 스크립트는 값 공간과 타입 공간을 다르게 두며 자바 스크립트의 키워드 마다 해석되는 방식(값, 타입, 둘다인지)이 달라진다.
</aside>

- 참고 자료
    
    [TypeScript 타입 시스템 뜯어보기: 타입 호환성](https://toss.tech/article/typescript-type-compatibility)
    
    [덕 타이핑과 구조적 타이핑](https://vallista.kr/%EB%8D%95-%ED%83%80%EC%9D%B4%ED%95%91%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91/)
    

## 2.3 원시 타입

- 원시 값과 원시 래퍼 객체
    - 자바 스크립트의 내장 타입은 파스칼 표기법 (ex  String)으로 표기함
    동적 타입 언어이기에 타입을 따로 선언할 필요는 없고 객체처럼 사용할 때나 사용함
    
    ```jsx
    const str = "hello"; // 원시 문자열
    console.log(str.length); // String 객체로 자동 변환 후 length 프로퍼티에 접근
    ```
    
    - 타입 스크립트의 경우 내장 타입에 대응되는 타입을 소문자로 표기함
    - 타입 스크립트의 타입 시스템이 자바 스크립트의 컴파일 시점에 적용되지 않기 때문에 서로 구별하기 위해 이렇게 분류함
    - 원시 래퍼 객체는 값이 아닌 객체 이기에 타입 스크립트에서 사용할 때 파스칼 표기법으로 이들을 불러오면 다른 의미로 인식하므로 표기법을 신경써서 불러와야 함 
    → 파스칼 표기법은 해당 원시 값을 래핑한 원시 래퍼 객체로, 소문자 표기는 해당 원시 값 타입으로 인지
- boolean
→ true, false만 할당 가능
- undefined
→ 정의되지 않은, 초기화 되지 않은 값을 의미
→ 옵셔널의 경우에도 undefined를 할당할 수 있음
- null
→ 빈 값을 할당할 때 사용
→ undefined와 달리 명시적, 의도적으로 값을 비어 있음을 보여주는 타입
- number
→ 자바 스크립트의 숫자에 해당하는 모든 원시 값 할당 가능 
(자바 스크립트는 정수, 부동소수점수 등을 구분하지 않기 때문)
→ NaN(숫자가 아님)이나 Infinity(무한대)도 포함될 수 있음
- bigInt
→ 자바 스크립트에서 가장 큰 수 (2^53 -1) 을 넘어가는 값을 처리하는 타입
→ number와 다른 타입이기에 상호작용 불가능
→ 3.2버전부터 사용할 수 있는 새로 도입된 타입
- string
→ 문자열을 할당할 수 있는 타입
→ 공백도 string 타입에 포함됨
- symbol
→ Symbol() 함수를 사용하여 어떤 값과도 중복되지 않는 유일한 값을 생성할 수 있음
→ 고유하고 변경 불가능한 값을 가짐
→ 고유한 식별자로 사용가능하며 객체 속성 키로 활용됨
- 모든 타입은 기본적으로 null, undefined를 포함하고 있지만 특정 옵션 활성화시 명시적으로 타입에 포함해야만 사용할 수 있음. 하지만 일반적으로 타입 가드를 사용하는 것이 안전하다고 여겨져 타입 가드를 사용함

<aside>
💡

1. 타입 스크립트의 경우 원시 값 타입은 소문자로, 원시 값을 래핑한 객체는 파스칼 표기법으로 표기함
2. 모든 원시 타입은 기본적으로 null, undefined를 포함하지만 이를 명시적으로 타입에 포함해야만 사용할 수 있도록 변경할 수 있으며 명시하는 것 보다 타입 가드 등을 사용하여 이 둘을 처리하는 것이 일반적이고 안전함
3. bigint는 number의 최대값을 넘어가는 값을 처리하는 타입, symbol은 고유하고 변경 불가능한 값을 처리하는 타입
</aside>

## 2.4 객체 타입

- 원시 타입에 속하지 않는 값은 모두 객체 타입임
- 타입 스크립트에서는 객체마다 개별적으로 타입을 지정할 수 있음
- object 
→ 자바 스크립트의 객체에 대응됨
→ 객체에 해당되는 모든 타입 값을 유동적으로 처리할 수 있기 때문에 정적 타이핑의 의미가 퇴색됨
→ any처럼 사용하지 않는 것이 권장됨 (any처럼 원시 타입 값을 처리하지는 않음)
- {}(중괄호)
→ 객체를 타이핑하고 생성할 때 사용됨
→ 중괄호 안에 객체 속성 타입을 지정해주는 식이며 객체가 중괄호 안에서 선언된 구조와 일치해야 함
→ `const obj = {}` 처럼 빈 객체를 만드는데 쓰일 수도 있음 하지만 이는 완전히 비어 있는 순수한 객체를 의미하지는 않고 자바 스크립트 프로토타입 체이닝을 object 객체 래퍼에서 제공하는 속성에는 접근 가능함
- ❓ 프로토타입 체이닝?
    
    

- array
→ 배열 자료 구조를 다루는 타입 
→ 자바 스크립트는 배열 안에 여러 타입의 값이 들어갈 수 있지만 타입 스크립트는 하나의 타입 값만 가짐
→ 대괄호[] 나 Array키워드로 선언할 수 있음
- type, interface 
→ 객체를 타이핑하기 위해 자주 사용하는 키워드
→ 중괄호를 사용하면서 매번 일일이 지정하기에는 중복되는 요소가 많음
→ 객체 타입을 type, interface 키워드를 사용해 반복적으로 사용 되어도 중복 없이 해당 타입 사용 가능
- function
→ 함수를 다루는 타입
→ function이라는 키워드 자체를 타입으로 사용하지는 않음 (반환이 있다면 값 타입 명시 해야함)
→ 매개 변수 또한 별도 타입으로 지정해야 함
→ 호출 시그니처 : 타입 스크립트에서 함수 타입을 정의할 때 사용하는 문법. 함수 타입은 매개변수와 반환 값의 타입으로 결정되는데, 매개변수와 반환 값의 타입을 명시하는 역할을 함

```tsx
//타입 스크립트는 함수 자체의 타입을 명시할때는 화살표 함수 방식으로만 시그니처를 호출함
type add = (a: number, b: number) => number;
```

<aside>
💡

타입 스크립트에서는 객체마다 개별적으로 타입을 지정할 수 있음

object는 모든 객체에 대응되지만 이로 인해 정적 타이핑의 의미가 퇴색되므로 사용하지 않는 걸 권장

function은 매개변수, 리턴 값 또한 별도 타입으로 지정해야 한다.

</aside>
