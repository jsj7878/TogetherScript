# 5장 (타입 활용하기)

## 5.1 조건부 타입

- 타입 스크립트는 조건부 타입을 사용해 조건에 따라 출력 타입을 다르게 설정할 수 있음
- 타입 스크립트의 조건부 타입은 삼항 연산자와 동일하게 `Condition ? A : B` 형태를 가짐
- 조건부 타입을 통해 중복되는 타입 코드를 제거하고 상황에 따라 적절한 타입을 얻을 수 있음
- extends와 제네릭을 활용한 조건부 타입
    - extends는 타입을 확장할 때 뿐만 아니라 타입을 조건부로 설정할 때도 사용됨
    - 제네릭 타입에서는 한정자 역할로도 사용이 됨
    - `T extends U ? X : Y` : T에 들어온 타입을 U에 할당할 수 있으면 X, 아니면 Y 타입
    - 타입 설정이 유니온으로만 되어 있으면 타입 스크립트는 조건에 따라 맞는 Data타입이 반환되는지를 추론할 수 가 없음
    - extends 활용 예시
        - 제네릭과 extends를 함께 사용하여 제네릭으로 받는 타입을 제한함. 휴먼 에러로 인한 잘못된 값 넘기기를 막을 수 있음
        - extends를 활용한 조건부 타입 설정을 통해 반환 값을 사용자가 원하는 값으로 구체화할 수 있음
- infer를 활용한 타입 추론
    - infer : 타입을 추론할 때 쓰임
    - `T extends Promise<infer K>[] ? K : any` : 제네릭으로 T를 받아서 T가 Promise로 래핑되어 있으면 K를 반환하고 아니면 any를 반환함. 이때 `Promise<infer K>`는 Promise의 반환 값을 추론하여 해당 값의 타입을 K로 한다는 의미
    - (infer를 사용할 때 불변객체를 넣는 이유는 뭘까? + 코드 다시 읽어보기)

## 5.2 템플릿 리터럴 타입 활용하기

- 타입 스크립트에서는 유니온 타입을 사용하여 변수 타입을 특정 문자열로 지정할 수 있음
- 템플릿 리터럴 타입을 통해 템플릿 리터럴 문법을 사용하여 특정 문자열에 대한 타입을 선언할 수 있음
- 이는 타입을 특정 문자열로 정확하게 검사하여 휴먼 에러를 방지하고 자동 완성 기능을 통해 개발 생산성을 높일 수 있음

## 5.3 커스텀 유틸리티 활용하기

- styled-component처럼 공통 컴포넌트의 경우 컴포넌트가 더 커지고 갯수가 늘어날수록 중복되는 타입이 많아지게 된다.
- 이런 문제를 유틸리티 타입으로 개선할 수 있다.
- 예를 들어 pick의 경우 props에서 필요한 부분만 선택하여 컴포넌트의 타입을 정의하면 중복되게 작성 안해도 더 편리하게 사용이 가능하다.
- PickOne 유틸리티 함수
    - 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 되지 않는 이슈가 있다.
    - 객체중 하나의 객체만 받고 싶은 상황에서 유니온으로 받게 되면 유니온은 합집합의 개념이라 속성이 모두 포함되어도 합집합의 범주에 들어가기 때문이다.
    - 이를 위해 식별할 수 있는 유니온 기법을 활용한다.
    - 식별할 수 있는 유니온 : 각 타입에 type이라는 공통된 속성을 추가하여 구분 짓는 방법. 타입 추론이 가능하지만 처음부터 이 타입으로 설계하지 않았으면 일일이 바꿔줘야 함..

- NonNullable 타입 검사 함수를 사용하여 간편하게 타입 가드하기
    - 일반적으로 if문을 통한 null 처리 타입 가드를 적용하지만, is 키워드와 NonNullable 타입으로 유틸 함수를 만들어 사용할 수 도 있음
    - NonNullable 타입 → 타입 스크립트에서 제공하는 유틸리티 타입. 제네릭으로 들어오는 T가 null, 또는 undefined이면 never 또는 T를 반환한다. 이를 통해 null, undefined가 아닌 경우를 제외할 수 있음
    - null이나 undefined가 들어갈 수 있는 타입들의 경우 NonNullable 을 활용하여 타입 가드를 반복하지 않고도 필터링 할 수 있게 된다.
    - 예시 ) `const shopAds = shopAdCampaignList.filter(NonNullable)`  : NonNullable인 친구들만 필터링
    - (이 타입 검사 함수는 우리수준에서도 쓸만한듯?)

## 5.4 불변 객체 타입으로 활용하기

- 상수값을 관리하는 객체 (theme 등등)를 사용할 때 열린 타입으로 설정할 수 있다. (`colors[key]`처럼) 하지만 이럴 경우 key를 string타입으로 설정하게 되면 colors에 어떤 값이 추가될지 모르기 때문에 any 타입을 반환하기도 한다.
- 따라서 이런 객체들을 사용할 때는 as const로 객체들을 불변으로 만든뒤 keyof연산자를 활용하여 해당 객체에 존재하는 키값들만 받도록 설정할 수 있다.
- 타입 스크립트의 keyof 연산자는 객체 타입을 받아 해당 객체의 키 값을 string 또는 number의 리터럴 유니온 타입을 반환한다. 인덱스 시그니처가 사용되었다면 인덱스 시그니처의 키 타입을 반환한다.
- 이렇게 나온 객체의 키값을 타입으로 다루려면 값 객체를 타입으로 변환해야 하는데, 이때 typeof 연산자를 활용하여 속성의 타입을 추론하여 사용할 수 있다.

(typeof keyof를 쓰는 이유는 아는데 보통 키랑 타입은 1대1 대응 개념, 상반되는 개념이라고 보면 typeof keyof 를 쓰면 원래 값이랑 같아지는거 아님? 사실 아닌거 아는데 그냥 물어보고 싶음)

## 5.5 Record 원시 타입 키 개선하기

- 객체 선언시 키가 어떤 값인지 명확하지 않다면 Record의 키를 string이나 number등 원시 타입으로 명시하곤함. 하지만 이는 유효하지 않은 키가 타입상으로는 문제가 없게 되기에 에러를 야기할 수 있음
- 키가 유한한 집합이라면
    - 유닛 타입을 사용하여 유효하지 않은 키가 사용되면 에러를 발생시키고 확인할 수 있음
- 키가 무한한 집합이라면
    - 무한한 키 집합의 경우 옵셔널 체이닝을 통해 안전하게 접근할 수 있다.
    
    > ❓ 옵셔널 체이닝
    객체의 속성을 찾을 때 중간에 null, undefined가 있어도 오류 없이 안전하게 접근하는 방법
    `?.` 문법으로 표현되며 옵셔널 체이닝을 사용할 때 null 또는 undefined인 속성이 있는지 검사한다.
    속성이 존재하면 해당 값을 반환하고 존재하지 않으면 undefined를 반환한다.
    > 
    - Partial을 사용하여 해당 값이 undefined일 수 있는 상태임을 표현할 수 있음
    - Partial을 사용하면 처리되지 않는 타입 값이 들어왔을 경우 undefined로 추론하여 개발자에게 처리가 필요하다고 표시해준다.