```jsx
12.1 앰비언트 타입 활용하기
12.1.1 앰비언트 타입 선언
12.1.2 앰비언트 타입 선언 시 주의점
12.1.3 앰비언트 타입 선언을 잘못 사용했을 때의 문제점
12.1.4 앰비언트 타입 활용하기
12.1.5 declare와 번들러의 시너지

12.2 스크립트와 설정 파일 활용하기
12.2.1 스크립트 활용하기
12.2.2 설정 파일 활용하기
12.2.3 에디터 활용하기

12.3 타입스크립트 마이그레이션
12.3.1 타입스크립트 마이그레이션의 필요성
12.3.2 점진적인 마이그레이션
12.3.3 마이그레이션 진행하기

12.4 모노레포
12.4.1 분산된 구조의 문제점
12.4.2 통합할 수 있는 요소 찾기
12.4.3 공통 모듈화로 관리하기
12.4.4 모노레포의 탄생
```

# 12.1 앰비언트 타입 활용하기

## 12.1.1 앰비언트 타입 선언

***~~타입스크립트 타입 선언이 가능한 확장자 파일 3가지~~***

타입스크립트 타입 선언은 `.ts, .tsx, .d.ts` 확장자 파일에서 선언할 수 있다.

### *️⃣ 앰비언트 타입 선언이 뭔가요?

.d.ts 확장자 파일에서는 타입 선언만 가능하고 값을 표현할 수 없다. 값을 포함하는 일반적인 선언과 구별하기 위해 .d.ts 확장자 파일에서 하는 타입 선언을 앰비언트 타입 선언이라고 한다.

> 앰비언트는 사전적으로 ‘주변의’라는 의미다.
> 

**declare**

앰비언트 타입 선언으로 값을 정의할 수 없다. declare 키워드를 사용해 어딘가에 자바스크립트 값이 존재한다는 사실을 선언할 수 있다.

> declare는 타입스크립트 컴파일러에 어떤 것의 존재 여부를 명시해주는 역할을 한다. 단순히 존재 여부만 알려주기 때문에 **컴파일 대상이 아니다.**
> 

### *️⃣ 대표적인 앰비언트 타입 선언 활용 사례

타입스크립트를 사용하다 보면 *.js, *.js 형식이 아닌 파일을 import할 때 종종 에러가 발생한다. 예시로 자바스크립트로 png 등 이미지 파일을 모듈로 import할 때, 자바스크립트에서는 정상 작동하나 타입스크립트에서는 에러가 발생한다.

**왜?**

타입스크립트는 기본적으로 .ts와 .js 파일만 이해한다. 그 외의 파일 형식은 인식하지 못한다. 그래서 에러가 발생한다.

이런 상황에서 타입스크립트의 `declare` 키워드를 사용해 아래와 같이 특정 형식을 모듈로 선언하면 타입스크립트 컴파일러에 미리 정보를 제공함으로써 에러를 수정할 수 있게 된다.

> 타입스크립트에게 ts,js 제외의 파일 형식을 declare를 사용해 제공해 에러를 방지한다.
> 

```tsx
declare module "*.png" {
  const src: string;
  export default src;
}
// 타입스크립트에서 사용 가능
import logo from "./logo.png";
```

### *️⃣ 자바스크립트로 작성된 라이브러리

**예시 : 자바스크립트로 작성된 npm 라이브러리**

해당 라이브러리에는 타입 선언이 없다. 따라서 타입스크립트에서 이걸 쓰면 import한 모듈은 모두 any로 추론된다. 만약 tsconfig.json 파일에서 any를 사용하지 못하게 설정했다면? 프로젝트가 빌드되지 않는다.

**어떻게 해결?**

앰비언트 타입 선언을 사용한다.

자바스크립트 라이브러리 내부 함수와 변수의 타입을 앰비언트 타입으로 선언하면 타입스크립트는 자동으로 .d.ts 확장자를 가진 파일을 검색하여 타입 검사를 진행하게 되므로 문제없이 컴파일된다.

또한 vscode와 같은 코드 편집기도 .d.ts 확장자를 가진 파일을 해석해 코드 작성시 유용한 타입힌트를 제공한다.

예시로 @types/react를 npm install -D 명령으로 설치하면 node_modules/@types/react에 index.d.ts와 global.d.ts가 설치된다.

```tsx
npm install -D @types/react
```

이러한 파일에는 리액트의 컴포넌트와 훅에 대한 타입이 정의되어 있다.

더 흥미로운 점은 tsc는 별도의 설정 없이도 node_modules/@types 디렉토리에 있는 타입 선언을 타입 검사에 활용한다는 것이다. vscode는 index.d.ts와 global.d.ts 파일을 활용해 코드 작성 시 타입 힌트를 제공한다.

> 앰비언트 타입 선언은 타입스크립트에게 “자바스크립트 코드 안에는 이런 정보들이 있다”고 알려주는 도구다.
> 

---

+. 리액트로 해서 이해가 잘 안되었는데 예시로 lodash 라이브러리를 사용한다고 해보자. 

```bash
npm install lodash
npm install -D @types/lodash
```

라이브러리를 설치할 때 @types/{설치하려는 라이브러리} 해서 함께 인스톨한다. 이는 라이브러리 개발자들이 미리 작성해 npm에 등록해둔 것이다. 이를 사용하면 타입스크립트가 알아서 다운로드 된 앰비언트 타입 선언을 활용한다. ide에서 이를 기반으로 타입 힌트를 제공한다.

💡`@types` 패키지가 없는 경우 직접 `.d.ts` 파일을 작성하거나 any 타입을 사용해야 할 것이다..

### *️⃣ 타입스크립트로 작성된 라이브러리

타입스크립트로 작성된 라이브러리라도 자바스크립트 파일과 .d.ts 파일로 배포되는 것이 일반적이다.

타입스크립트 파일을 직접 배포해 라이브러리 사용자가 타입스크립트를 컴파일할 때 라이브러리 코드도 함께 컴파일하게 할 수도 있다. 

그러나 자바스크립트 파일과 .d.ts 파일로 배포하면 라이브러리 코드를 따로 컴파일하지 않아도 되기 때문에 컴파일 시간이 크게 줄어든다. 

- **타입스크립트로 작성된 라이브러리로 자바스크립트와 앰비언트 파일로 배포하는 이유가 뭔가요?**
    - 컴파일된 자바스크립트를 사용하면 사용자가 또 컴파일할 필요가 없다. 타입스크립트로 받으면 사용자가 컴파일해서 자바스크립트로 만드는 과정을 또 거쳐야 한다. 컴파일 시간이 단축되는 효과.
    - .d.ts 파일을 통해 개발자가 타입 힌트와 자동완성을 사용할 수 있어 편리하다.
    

또 .d.ts 파일이 있기 때문에 사용하는 이 파일에 정의된 타입 정보를 활용해 라이브러리를 사용할 수 있다. 

또 tsconfig.json 파일의 declaratio을 true로 설정하면 타입스크립트 컴파일러는 자동으로 .d.ts 파일을 생성한다. 라이브러리 배포할 때는 해당 설정을 true로 해두는 것이 편리하다.

### *️⃣ 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에게 알릴 때

타입스크립트로 직접 구현하지 않았지만 실제 자바스크립트 어딘가에 전역 변수가 정의되어 있는 상황을 타입스크립트에 알릴 때 앰비언트 타입 선언을 사용한다.

예를 들어 웹뷰를 개발할 때 네이티브 앱과의 통신을 위한 인터페이스를 네이티브 앱이 window 객체에 추가하는 경우가 많다. 이렇게 전역 객체인 window에 변수나 함수를 추가하면 타입스크립트에서 직접 구현하지 않았더라도 실제 런타임 환경에서 해당 변수를 사용할 수 있다.

**네이티브 앱에서 window 전역객체에 속성을 추가할 때**

```tsx
// 네이티브 앱에서 추가
window.deviceId = "12345";
window.appVersion = "1.0.0";
// 타입스크립트에서 접근하면 에러 발생
console.log(window.deviceId); // 에러: 'deviceId'는 'Window' 타입에 존재하지 않습니다.

```

네이티브 앱에서 window 전역 객체에 deviceId나 appVersion 같은 값을 할당해주는 시나리오를 떠올려보자. window 객체의 속성은 타입스크립트로 직접 정의한 값이 아니기 때문에 타입스크립트는 해당 속성이 window 객체의 타입에 존재하지 않는다고 판단한다. 따라서 해당 속성에 접근하려고 하면 window 객체에 존재하지 않는 속성이라는 에러가 발생한다. 이 때 global namespace에 있는 window 객체에 해당 속성이 정의되어 있다는 것을 나타내기 위해 앰비언트 타입 선언을 사용할 수 있다.

```tsx
// global.d.ts
declare global {
  interface Window {
    deviceId: string | undefined;
    appVersion: string;
  }
}
```

이제 타입스크립트에서 접근해도 에러가 발생하지 않는다.

```tsx
// app.ts
console.log(`Device ID: ${window.deviceId}`); // "Device ID: 12345"
console.log(`App Version: ${window.appVersion}`); // "App Version: 1.0.0"
```

## 12.1.2 앰비언트 타입 선언 시 주의점

### ⚠️ 타입스크립트로 만드는 라이브러리에는 불필요

위에서 말한 tsconfig.json의 declaration을 true로 설정하면 타입스크립트 컴파일러가 .d.ts 파일을 자동으로 생성한다. 수동으로 작성할 필요가 없다.

### ⚠️ 전역으로 타입을 정의하여 사용할 때 주의해야 할 점

1. 서로 다른 라이브러리에서 동일한 이름의 앰비언트 타입 선언을 한다면 충돌이 발생해 어떤 타입 선언이 적용될지 알기 어렵고 제대로 동작하지 않을 수 있다. 
2. 또한 앰비언트 타입 선언은 명시적인 import나 export가 없기 때문에 코드의 의존성 관계가 명확하지 않아 수정에 어려움이 있을 수 있다.

## 12.1.3 앰비언트 타입 선언을 잘못 사용했을 때의 문제점

**.ts 파일 내의 앰비언트 변수 선언은 개발자에게 혼란을 야기한다.**

대표적으로 .ts 파일 내부에 앰비언트 변수를 선언할 때 앰비언트 타입의 의존성 관계가 보이지 않기 때문에 변경에 의한 영향 범위를 파악하기 어렵다. 앰비언트 타입은 명시적인 import나 export 없이 코드 전역에서 사용할 수 있기 때문이다. 규모가 커지면 수정이 더 어려워진다.

**앰비언트 타입 선언은 .d.ts에서만 가능하다?**

다음과 같이 declare 키워드를 사용한 앰비언트 타입 선언은 .d.ts 파일이 아닌 .ts, .tsx 파일 내에서도 할 수 있다.

```tsx
// src/index.tsx
import React from "react";
import ReactDOM from "react-dom";
import App from "App";

declare global {
	interface Window {
			Example: string;
	}
}
const SomeComponent = () = > {
  return <div>앰비언트 타입 선언은 .tsx 파일에서도 가능</div>;
};
```

이후 src/tsest.tsx 파일에서도 import 없이 사용 가능하다.

```tsx
// src/test.tsx
window.Example; // 에러 발생하지 않음
```

**결론 : 앰비언트 타입 선언은 .d.ts에서만 해라**

앰비언트 타입 선언은 일종의 전역 타입을 선언한 것이다. 이를 이곳저곳에 ts 파일 내에서 작성하게 되면 파악이 어려워진다. 그러므로 .d.ts 파일 내에서만 타입 선언을 하는 것을 권장한다. 

## 12.1.4 앰비언트 타입 활용하기

더 잘 활용해보기

### ☑️ 타입을 정의하여 import 없이 전역으로 공유

앰비언트 타입은 일종의 전역 변수처럼 전역에서 import 없이 사용할 수 있다.

앰비언트 타입으롤 유틸리티 타입을 선언하면 모든 코드에서 import 하지 않고 해당 타입을 사용할 수 있다. 마치 내장 타입 유틸리티 함수를 쓰는 것처럼…

```tsx
// src/index.d.ts
type Optional<T extends object, K extends keyof T = keyof T> = Omit<T, K> &
  Partial<Pick<T, K>>;

// src/components.ts
type Props = { name: string; age: number; visible: boolean };
type OptionalProps = Optional<Props>; 
// Expect: { name?: string; age?: number; visible?: boolean;
type OptionalProps2 = Optional<Props, 'age'>; 
// Expect: { name?: string; age: number; visible?: boolean;
```

### ☑️ declare type 활용하기

보편적으로 많이 사용하는 커스텀 유틸리티 타입을 declare type으로 선언하여 전역에서 사용할 수 있다. 

**Nullable**

T에 null을 허용하도록 하는 유틸리티 타입. 값이 null이 가능할 때 사용한다. 명시적으로 null 가능성을 알린다.

```tsx
declare type Nullable<T> = T | null;

const name: Nullable<string> = "woowa"; // 예시1
type User = { // 예시2
  id: number;
  email: string;
  phoneNumber: Nullable<string>;
};
```

### ☑️ declare module 활용하기

CSS-in-JS 라이브러리의 사례

- theme 인터페이스 타입을 확장해 theme 타입이 자동으로 완성되도록 하는 기능이 추가되었다.
- CSS-in-JS 라이브러리는 기존의 폰트 크기, 색상 등을 객체로 관리한다. 이렇게 정의된 theme에서 스타일 값을 가져와 기존 인터페이스 타입과 통합하여 theme 타입이 자동으로 완성되는 기능을 지원하고 있다.

```tsx
const fontSizes = { xl: "30px", // ...
};

const colors = {
  gray_100: "#222222",
  gray_200: "#444444",
  // ...
};

const depths = {
  origin: 0, foreground: 10, dialog: 100, // ...
};

const theme = {
  fontSizes, colors, depths,
};

declare module "styled-components" {
  type Theme = typeof theme;
  export type DefaultTheme = Theme;
}
```

이외에도 로컬 이미지나 SVG같이 외부로 노출되어 있지 않은 파일을 모듈로 인식해 사용할 수 있게끔 만들 수 있다.

```tsx
// src/image-modules.d.ts
declare module "*.gif" {
  const src: string;
  export default src;
}
```

### ☑️ declare namespace 활용하기

Node.js 환경에서 .env 파일을 사용할 때, declare namespace를 활용하여 process.env로 설정값을 손쉽게 불러오고 환경변수의 자동 완성 기능을 쓸 수 있다.

```tsx
declare namespace NodeJS {
  interface ProcessEnv {
    readonly API_URL: string;
    readonly API_INTERNAL_URL: string;
    // ...
  }
}
```

process.env를 통해 접근하는 변수 또한 타입을 지정할 수 있기 때문에 as 단언을 사용하지 않아도 된다.

**namespace 사용하지 않은 경우 : as로 타입 단언해야 한다**

```tsx
// .env
API_URL = "localhost:8080";
// 타입 단언 사용
console.log(process.env.API_URL as string);
```

**namespace 사용한 경우**

```tsx
// .env
API_URL = "localhost:8080";

declare namespace NodeJS {
  interface ProcessEnv {
    readonly API_URL: string;
  }
}
// 타입 단언 생략해도 된다
console.log(process.env.API_URL);
```

### ☑️ declare global 활용하기

declare global 키워드는 전역 변수를 선언할 때 사용한다. 대표적으로 네이티브 앱과의 통신을 위한 인터페이스를 Window 객체에 추가할 때 앰비언트 타입 선언을 활용할 수 있다.

**iOS 웹뷰에서 자바스크립트로 네이티브 함수를 호출하기 위한 함수 정의**

이후 자동완성 기능을 활용 가능

```tsx
declare global {
  interface Window {
    webkit?: {
      messageHandlers?: Record<
        string,
        {
          postMessage?: (parameter: string) => void;
        }
      >;
    };
  }
}
```

## 12.1.5 declare와 번들러의 시너지

declare global로 전역 변수를 선언하는 과정과 번들러를 통해 데이터를 주입하는 절차를 함께 활용하면 시너지를 낼 수 있다.

전역에 _color 변수가 존재함을 타입스크립트 컴파일러에 알리면 해당 객체를 활용할 수 있다.

```tsx
const color = {
  white: "#ffffff",
  black: "#000000",
} as const;

type ColorSet = typeof color;

declare global {
  const _color: ColorSet;
}

const white = _color["white"]; // _color 활용할 수 있다
```

**문제**

아직 ColorSet 타입을 가지고 있는 _color 객체의 실제 데이터가 존재하지 않는다. 다시 말해 앞의 코드는 타입스크립트 에러를 발생시키지 않지만, 코드가 실행될 경우에는 실제 데이터가 없기 때문에 기대하는 동작과 다를 수 있다.

**어떻게 해결? 번들 시점에 번들러를 통해 해당 데이터를 주입**

롤업(rollup) 번들러의 inject 모듈로 데이터를 주입하는 예시

- data.ts에서 색상 정의, type.ts에서 해당 데이터로부터 타입을 정의하여 전역적으로 선언
- index.ts 파일에서는 전역 타입으로 선언된 변수인 _color[’white’]를 콘솔로 출력.
- 가장 중요한 롤업 번들러 설정에서 inject 모듈을 사용해 _color에 해당하는 데이터를 삽입하고 있다.

```tsx
// data.ts
export const color = {
  white: "#ffffff",
  black: "#000000",
} as const;

// type.ts
import { color } from “./data”;
type ColorSet = typeof color;
declare global {
		 const _color: ColorSet;
}

// index.ts
console.log(_color[“white”]); // O 출력 : #ffffff

// rollup.config.js
import inject from "@rollup/plugin-inject";
import typescript from "@rollup/plugin-typescript";
export default [
  {
    input: "index.ts",
    output: [
      {
        dir: "lib",
        format: "esm",
      },
    ],
    plugins: [typescript(), inject({ _color: ["./data", "color"] })],
  },
];
```

<aside>
🔬

**inject 모듈**

inject는 import문의 경로를 분석하여 데이터를 가져온다.

`import {color} from './data'`

./data 경로에서 color를 가져오는 경우, [’./data’, ‘color’]로 지정하여 어떤 데이터 값을 가져올지 명시할 수 있다.

</aside>

# 12.2 스크립트와 설정 파일 활용하기

타입스크립트에서 스크립트와 tsconfig 등을 잘 활용하면 개발 생산성을 높일 수 있다.

## 12.2.1 스크립트 활용하기

### ✅ 실시간으로 타입을 검사하자

일반적으로 타입스크립트 프로젝트에서는 에디터가 가능한 한 빠르게 타입 에러를 감지해준다. 

**문제**

그러나 컴퓨터 성능이 떨어지거나 프로젝트 규모가 커지면 에디터가 타입 에러를 알려주는 속도가 느려진다. (특정 파일을 열어야만 타입 에러가 나타나거나, 에디터에서 에러가 없는 걸 확인 후 커밋했는데 이후 깃훅 도구인 husky에 의해 타입 에러 발견 등)

**어떻게 해결?**

이럴 때 아래 스크립트를 활용해 실시간으로 에러를 확인할 수 있다.

```tsx
yarn tsc -noEmit -incremental -w
npx tsc -noEmit -incremental -w
```

- **package.json에 스크립트 추가해서 더 쉽게 하기**
    
    ```tsx
    // package.json
    {
      "scripts": {
        "type-check": "tsc -noEmit -incremental -w"
      }
    }
    
    // 이후에는 아래 명령어로 실행 가능
    npm run type-check
    ```
    

스크립트는 프로젝트의 tsc(타입스크립트 컴파일러)를 실행한다.

- noEmit 옵션은 자바스크립트로 된 출력 파일을 생성하지 않도록 설정
- incremental 옵션은 증분 컴파일을 활성화해 컴파일 시간을 단축
- w는 파일 변경 사항을 모니터링

> “**증분 컴파일**”은 매번 모든 대상을 컴파일하는 것이 아니라 변경 사항이 있는 부분만을 컴파일하는 것을 말하며, 이를 활용하면 컴파일 시간을 줄일 수 있다.
> 

**효과**

터미널에서 앞의 스크립트를 실행하면 파일이 변경될 때마다 tsc가 실행되어 어디에서 타입에러가 발생했는지를 실시간으로 추적할 수 있다.

### ✅ 타입 커버리지 확인하기

타입스크립트를 사용하면서 any 타입을 이곳저곳에서 남발하면 타입스크립트의 장점을 활용하지 못한다. 따라서 현재 프로젝트에서 얼마나 타입스크립트를 적절하게 쓰고 있는지 확인할 필요가 있다. 프로젝트의 모든 부분이 타입스크립트 통제하에 돌아가고 있는지를 정량적으로 판단하기 위해 다음과 같은 스크립트를 사용할 수 있다.

> 타입스크립트 활용성 정량적 판단
> 

```tsx
npx type-coverage --detail
```

**효과**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3529de1c-a19d-49ac-aa2d-b4bf2e3fafce/42fbd64d-6af9-4044-8ed7-58ecb93d6462/image.png)

스크립트를 사용하면 현재 프로젝트의 타입 커버리지와 any를 사용하고 있는 변수의 위치가 나타난다.

예시에선느 전체의 약 86%에 해당하는 변수가 타입으로 지정되어 있다. 반대로 말하면 약 14%는 any이다.

타입스크립트로 마이그레이션 중인 프로젝트나 레거시 코드가 많은 프로젝트를 다룰 때 타입 커버리지를 체크해 더 나은 코드 퀄리티로 리팩토링하기 위한 기반 마련에 도움이 된다.

## 12.2.2 설정 파일 활용하기

### ✅ 타입스크립트 컴파일 속도 높이기

tsconfig의 incremental 속성을 활용하여 타입스크립트의 컴파일 속도를 높일 수 있다. incremental 속성을 true로 설정하면 증분 컴파일이 활성화되어 매번 모든 대상을 컴파일하는 것이 아니라 변경된 부분만 컴파일하게 된다. 결과적으로 컴파일 타임을 줄일 수 있다.

```tsx
// tsconfig에 추가
{
  "compilerOptions": {
    //...
    incremental: true
  }
}
```

스크립트

```tsx
yarn tsc --noEmit --incremental --diagnostic
```

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3529de1c-a19d-49ac-aa2d-b4bf2e3fafce/d50dd91f-e681-49b9-a408-9aac0ac17483/image.png)

Total time이 10초 이상 차이 난다. 특히 검사 시간인 Check time이 차이난다.

## 12.2.3 에디터 활용하기

### ☑️ 에디터에서 타입스크립트 서버 재시작하기

가끔 정의된 타입이 있는 객체임에도 import 되지 않거나 자동 완성 기능이 동작하지 않을 수 있다.

이럴 때는 타입스크립트 서버를 재실행한다.

VSCode에서는 `command+shift+P` 로 Restart TS server를 실행한다.

# 12.3 타입스크립트 마이그레이션

## 12.3.1 타입스크립트 마이그레이션의 필요성

반드시 마이그레이션하는 것이 정답은 아니다. 새로 구축하는 것이 더 나을 수 있다. 상황에 따라 판단해야 한다.

## 12.3.2 점진적인 마이그레이션

작은 것부터 서서히 마이그레이션할 수 있다면 베스트. 

하지만 단순히 allowJS를 true, noImplicitAny를 false로 설정한 채 무기한으로 마이그레이션을 미루는 것은 지양해야 한다. 프로젝트에 데드라인은 필요하다. 

## 12.3.3 마이그레이션 진행하기

**단계**

타입스크립트 개발환경을 설정하고, 빌드 파이프라인에 타입스크립트 컴파일러를 통합한다.

1. tsconfig.json 파일에서 allowJS를 true로, noImplicitAny를 false로 설정해야 한다.
2. 작성된 자바스크립트 파일을 타입스크립트 파일로 변환한다. 필요한 타입과 인터페이스를 하나씩 정의해 함수 시그니처를 추가해나간다.
3. 기존 자바스크립트 파일을 모두 타입스크립트로 변환했다면 tsconfig.json 파일에서 allowJS를 false로 변경하고, noImplicitAny를 true로 설정해 타입이 명시되지 않은 부분이 있는지 점검한다.

# 12.4 모노레포

여러 프로젝트는 대부분 개별 프로젝트마다 별도의 레포지토리로 관리한다. 하지만 프로젝트 사이에 공통된 요소를 찾아 통합하면 더 효율적으로 관리할 수 있다.

## 12.4.1 분산된 구조의 문제점

3개의 독립적인 프로젝트가 있다고 한다. 개발자는 각 레포지토리에서 해당 프로젝트를 위한 Jest, 바벨, ESLint, 타입스크립트 설정 파일을 별도로 구성하고 빌드 파이프라인, 공통적인 컴포넌트 그리고 해당 프로젝트에 필요한 소스코드를 독립적으로 관리한다.

만약 현재 프로젝트에 필요한 기능이 다른 프로젝트에 존재한다면 해당 기느을 복사 붙여넣기해서 빠르게 구현할 수 있다.

**단점은?**

이를 통해 개발시간을 아낄 수 있지만 프로젝트 관리 측면에서 어려움이 생기기도 한다. 예시로 복사붙여넣기한 모든 것이 사실 버그가 발생하면? 복사붙여넣기한 기능에서 사용하는 라이브러리에 문제가 생긴다면?

개별 프로젝트를 전부 수정해야 할 수 있다.

개발자가 변경이 필요한 지점을 모두 인지하고 있어야 하기 때문에 개발자 경험 DX가 저하될 수 있다. 장기적으로도 프로젝트 관리가 어려워지면서 업무 효율이 악화되는 현상이 발생한다.

이처럼 분산된 구조는 생산성을 떨어뜨리는 결과를 초래한다. 

**어떻게 해결?**

반복되는 코드를 함수화하여 통합하듯이 한 곳에서 프로젝트를 관리할 수 있도록 통합해야 한다.

## 12.4.2 통합할 수 있는 요소 찾기

프로젝트 내에서 공통으로 통합할 수 있는 요소를 찾아야 하낟

각 프로젝트의 utils 디렉토리를 보자 아래 4개 파일은 통합할 수 있을 것 같다. 물론 각 파일의 소스코드가 같지 않다면 일부 수정해야 한다.

```tsx
utils/
├── clipboard.ts
├── date.ts
├── logger.ts
└── validation.ts
```

## 12.4.3 “공통 모듈화”로 관리하기

소스코드를 수정한 다음에 모듈화를 통해 통합할 수 있다. 이 과정에서 npm과 같은 패키지 관리자를 활용해 공통 모듈을 생성하고 관리한다면 각 프로젝트에서 간편하게 모듈과 의존성을 맺고 사용할 수 있게 된다. 

**장점**

새로운 프로젝트를 시작하더라도 모듈을 통해 코드를 재사용할 수 있으며, 특정 기능의 변경이 필요할 때는 해당 모듈의 소스코드만 수정하면 되기 때문에 유지보수도 쉬워진다.

**여전히 아쉬운 점**

공통 모듈에 변경이 발생한다면 해당 모듈을 사용하는 프로젝트에서도 추가 작업이 필요할 수 있다. 또 공통 모듈의 개수가 늘어나면 관리해야 할 레포지토리도 그만큼 늘어난다.

새로운 공통 모듈이 필요하다면 개발자는 새로운 레포지토리를 생성하고 개발환경을 설정하며 패키지 관리자를 사용해 모듈을 게시해야 한다. 새로운 프로젝트를 시작할 때도 빌드를 위한 CI/CD 파이프라인, Lint, 테스트 등도 별도로 설정해야 한다.

## 12.4.4 모노레포의 탄생

모노레포란 버전 관리 시스템에서 여러 프로젝트를 하나의 레포지토리로 통합하여 관리하는 소프트웨어 개발 전략이다. 이전에는 다양한 기능을 가진 프로젝트를 하나의 레포지토리로 관리하는 모놀리식 기법을 주로 사용했다.

**모놀리식 구조 단점**

모놀리식 구조는 코드 간의 직접적인 의존이 발생하여 일부 로직만 변경될 때도 전체 프로젝트에 영향을 줄 수 있다. 이에 따라 설계적인 측면과 빌드 및 배포 등에서 효율적이지 못했다.

**효율적인 구조?**

효율적인 구조에 대한 수요가 생겼고 거대한 프로젝트를 작은 프로젝트의 집합으로 나누어 관리하는 폴리레포 방식과 하나의 레포지토리로 모든 것을 관리하는 모노레포 방식이 등장하게 되었다. 최근에는 작은 프로젝트에서도 번들러, 테스트, Lint, CI/CD 스크립트나 도커 등 다양한 설정을 적용한다.

이러한 상황에서 모노레포를 사용하면 개발 환경 설정도 통합할 수 있어서 더 효율적인 관리가 가능해진다. 

### 🌷 모노레포로 관리했을 때의 장점

모노레포는 앞서 설명한 대로 여러 프로젝트를 하나의 레포지토리로 통합하여 관리하며, 프로젝트마다 개별적인 레포지토리를 만드는 방식과는 달리 Lint, CI/CD 등 개발 환경 설정도 통합적으로 관리하기 때문에 불필요한 코드 중복을 줄여준다.

개별적으로 프로젝트를 형성하는 폴리레포와는 다르게 공통 모듈도 동일한 프로젝트 내에서 관리되므로 별도의 패키지 관리자를 통해 모듈을 게시하지 않아도 된다. 이에 따라 기능 변화를 쉽게 추적하고 의존성을 관리할 수 있게 된다.

### 🌷 모노레포로 관리했을 때의 단점

 모노레포로 프로젝트를 관리할 때 시간이 지나면서 레포지토리가 거대해질 수 있다. 그리고 하나의 레포지토리에 여러 팀의 이해관계가 얽혀있다면 소유권과 권한 관리가 복잡해질 수 있다. 따라서 각 프로젝트나 모듈의 소유권을 명확히 정의하고 규칙을 설정해야 하는 과정이 별도로 필요하다.

### 우형 이야기

1. 모노레포 안에 있는 패키지의 개별적인 버저닝이 필요했다. 특히 디자인 시스템을 개발하고 있기 때문에 패키지 수가 많다. 패키지들끼리 연관성이 높아서 한 곳에서 효율적으로 관리할 필요가 있다고 생각했다.
2. 공통적인 코드를 관리하는 측면에서 모노레포가 유용하다. 하지만 하나의 프로젝트처럼 관리되지 않는 모노레포를 사용할 때는 아쉬운 점이 있다. 개발실에서 쓰는 모든 어드민을 합쳐놓은 모노레포가 있다. 같은 개발실에서 사용하는 모노레포이지만 한 팀이 아니라 여러 부서에서 관리하다 보니 깃 로그를 읽고 변경 내역을 빠르게 파악하는게 어렵다. 또한 모노레포로 합쳐져 있지만 배포 주기가 각각 다르다. 이런 부분까지 고려해서 어떻게 모노레포를 더 잘 활용할 수 있을지 고민해야 한다.
3. pnpm과 Lerna + npm workspace를 사용해 모노레포를 관리한다. 모노레포를 사용하면 패키지 간의 연관 관계가 있을 때 버저닝이 확실하게 보장된다는 장점이 있다. 그리고 공통적인 부분을 새로운 패키지로 분리해야 할 때도 빠르게 작업할 수 있어 좋다.
하지만 모노레포로 개발하게 되면 모든 패키지를 보게 되어 퍼포먼스가 떨어지는 것 같기도 하다. 예전에 초창기 설정 때 공통 의존성이 꼬이는 문제가 발생한 적이 있는 골치아팠다.
4. Lerna를 사용해 모노레포를 관리하다. 특히 디자인 시스템에서는 모든 모노레포 패키지를 순회하여 빌드하거나 npm 레지스트리 등록 등의 작업을 해야 하는데, 이런 동작과 관련된 예시를 찾아보기 좋았던 게 Lerna였다. 또한 패키지 번들러로 롤업을 사용해야 했는데 Lernna를 사용한 관련 예시가 많아서 큰 도움이 되었다.
5. yarn berry를 모노레포 관리에 사용한다. 근데 node_modules를 사용하지 않는 구조를 채택하면서 문제 발생. 다른 프로젝트에서는 nx를 사용하는데 다양한 기능을 써야할 때 편리하다.  특히 특정 패키지만 배포해야 할 때 필요한 모듈만 정리해서 제공해주는 점이 좋았다.
