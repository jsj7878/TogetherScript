# 8장 (JSX에서 TSX로)

## 8.1 리액트 컴포넌트의 타입

- 클래스 컴포넌트 타입
    - 훅 도입 이전에 상태 관리와 생명주기 메서드를 사용할 수 있는 유일한 방법이었음
    - 클래스 기반으로 `React.Component`를 상속받아 정의됨
    - 클래스 컴포넌트에서는 `state`를 사용하여 컴포넌트의 상태를 관리 가능
    - 생명주기 메서드 사용 가능
        - `componentDidMount`: 컴포넌트가 DOM에 마운트된 후 호출
        - `componentDidUpdate`: 컴포넌트가 업데이트된 후 호출
        - `componentWillUnmount`: 컴포넌트가 DOM에서 제거되기 직전에 호출
    - 클래스 컴포넌트가 상속 받는 `React.Component` 와 `React.PureComponent` 는 props와 상태 타입을 제너릭으로 받을 수 있으며 상태에 대한 타입 또한 지정할 수 있다.
- 함수 컴포넌트 타입
    - 함수 표현식을 사용하여 함수 컴포넌트를 선언할 때 `React.FC` 혹은 `React.VFC` 로 타입을 지정할 수 있다.
    - 최신 버전은 VFC가 삭제되고 FC에서 children이 사라졌다. (FC는 기존에 암묵적으로 children을 포함하고 있어서 해당 컴포넌트에서 children 컴포넌트를 사용하지 않아도 children props를 허용했음)\
    - 함수 컴포넌트의 타입을 지정해줄 때는 `React.FC` 혹은 props 타입을 직접 지정하여 타이핑하자
    
    > ❓ children이란?
    컴포넌트의 자식 요소를 나타내는 속성
    컴포넌트 내부에서 props.children을 사용하면 컴포넌트 태그 안의 내용을 동적으로 렌더링 할 수 있음
    예시)
    > 
    > 
    > ```tsx
    > function Wrapper(props) {
    >     return <div className="wrapper">{props.children}</div>;
    > }
    > 
    > function App() {
    >     return (
    >         <Wrapper>
    >             <h1>Hello, World!</h1>
    >             <p>This is a child element.</p>
    >         </Wrapper>
    >     );
    > }
    > ```
    > 
- Children props 타입 지정
    - 가장 보편적인 children 타입은 `ReactNode | undefined` 이다.
    - ReactNode 는 ReactElement 외에도 boolean, number 등 여러 타입을 포함하고 있는 타입으로 구체적으로 타이핑하는 용도에는 적합하지 않다.
    - 특정 요소만 허용하고 싶을 때는 children에 대해 추가적으로 타이핑해줘야 한다.
    

> ❓클래스 컴포넌트에 비해 함수 컴포넌트가 갖는 이점이 뭘까?

1. **간결하고 읽기 쉬운 코드**
> 
> - **클래스 컴포넌트**는 상태와 생명주기 메서드를 사용하려면 장황한 코드가 필요합니다. 특히 `constructor`와 `this` 바인딩 등 추가적인 코드가 포함됩니다.
> - **함수 컴포넌트**는 Hooks 덕분에 상태 관리와 생명주기 로직을 훨씬 간단하게 구현할 수 있습니다.
> 
> 2. **Hooks의 강력한 기능**
> 
> - React의 Hooks는 함수 컴포넌트에서도 상태 관리와 생명주기 로직을 간단히 처리할 수 있도록 합니다.
> - Hooks는 상태와 생명주기 로직을 **필요한 곳에서만 사용**할 수 있어 더 유연한 구조를 제공합니다.
> 
> 3. **로직 재사용성 개선**
> 
> - 클래스 컴포넌트에서 로직을 재사용하려면 고차 컴포넌트(HOC)나 Render Props 패턴을 사용해야 했습니다. 이 방식은 코드가 복잡해지고 중첩이 많아지는 단점이 있었습니다.
> - Hooks는 **커스텀 Hook**을 통해 로직을 간단히 추출하고 재사용할 수 있습니다.

- render 메서드와 함수 컴포넌트의 반환 타입
    - React.ReactElement
        - React.createElement의 반환 타입
        - react는 실제 DOM이 아니라 가상의 DOM을 기반으로 렌더링하는데 이때 가상 DOM의 엘레먼트를 ReactElement 형태로 저장한다.
        - 리액트 컴포넌트를 객체 형태로 저장하기 위한 포맷
    - JSX.Element
        - ReactElement를 확장하고 있는 타입
        - 글로벌 네임 스페이스에 정의되어 있어 외부 라이브러리에서 컴포넌트 타입을 재정의 할 수 있는 유연성을 제공함
        - 컴포넌트 타입을 재정의하거나 변경하는 것이 용이해짐
        - ReactNode
            - React에서 렌더링 할 수 있는 모든 요소를 포함하는 타입
            - React 컴포넌트가 반환하거나 props로 전달 될 수 있는 모든 데이터 유형을 포괄하는 타입
    - 포함관계는 다음과 같다
        - ReactNode > ReactElement > JSX.Element
- 활용하기
    - ReactElement
        - JSX의 createElement 메서드 호출로 생성된 리액트 엘리먼트 타입
    - ReactNode
        - ReactChild 외에 boolean, null, undefined 등 훨씬 넓은 범주의 타입을 포함함
        - 리액트의 render 함수가 반환할 수 있는 모든 형태
    - JSX.Element
        - ReactElement의 특정 타입으로 props와 타입 필드에 대해 any 타입을 가지는 타입
- 사용 예시
    - ReactNode
        - 리액트의 render 함수가 반환할 수 있는 모든 형태를 담고 있기 때문에 리액트 컴포넌트가 가질 수 있는 모든 타입을 의미한다.
        - children props에 어떤 타입이든 지정하고 싶으면 ReactNode 타입으로 children을 지정하자
    - JSX.Element
        - props와 타입 필드가 any인 리액트 엘리먼트를 나타냄
        - 리액트 엘리먼트를 prop으로 받아 render props 패턴으로 컴포넌트를 구현할 때 유용하게 활용할 수 있음
        - prop에 JSX문법만 삽입하거나 props에 접근하여 넘겨받은 컴포넌트의 상세한 데이터를 가져올 수 있음
    - ReactElement
        - 원하는 컴포넌트의 props를 ReactElement의 제네릭으로 사용할 수 있음
- HTML 요소 타입 활용하기
    - HTML 태그의 속성 타입을 활용하는 방법은 2가지가 있다
    - DetailedHTMLProps
        - 쉽게 HTML 태그 속성과 호환되는 타입을 선언할 수 있음
## 8.2 타입 스크립트로 리액트 컴포넌트 만들기

- 타입 스크립트는 공통 컴포넌트에 어떤 타입의 속성이 제공되어야 하는지를 알려주고 필수로 전달되어야 하는 속성이 전달되지 않았을 때는 에러를 표시하여 프로젝트의 안정성을 높힘
- 컴포넌트의 속성 타입 등을 명시하기 위해 JSDocs (주석 문법 중 하나)를 사용할 수 있다.

> ❓ JSDocs란?
 JavaScript 코드에 주석을 추가하여 코드의 구조, 기능,  동작 등을 문서화할 수 있는 주석 문법
> 
> 
> ### JSDoc의 주요 태그
> 
> | 태그 | 설명 |
> | --- | --- |
> | `@param` | 함수의 매개변수를 설명 |
> | `@returns` | 함수의 반환값을 설명 |
> | `@type` | 변수나 객체의 타입을 명시 |
> | `@typedef` | 사용자 정의 타입을 정의 |
> | `@property` | 객체 속성의 타입과 설명을 명시 |
> | `@example` | 코드 사용 예제를 추가 |
> | `@deprecated` | 더 이상 사용되지 않는 함수나 속성을 명시 |
- JSDocs의 경우 각 속성의 대략적인 타입과 역할을 파악할 수 있지만 구체적인 타입을 지정하기는 어렵기 때문에 JSX파일의 확장자를 TSX로 변경하여 해당 컴포넌트의 **props에 대한 인터페이스를 작성**하는 것으로 해결이 가능하다.
- DOM 엘리먼트에 등록되어 처리하는 이벤트 리스너 (onclick, onchange 같은)와 달리 리액트 컴포넌트에 등록되는 이벤트 리스너는 onClick, onChange 처럼 카멜 케이스로 표기한다.
- 리액트 이벤트는 이벤트 버블링 단계에서 호출되며 이벤트 캡처 단계에서 이벤트 핸들러를 등록하기 위해서는 onClickCapture 처럼 리스너 이름 뒤에 Capture를 붙여야 한다.

> ❓ 이벤트 버블링, 캡처 단계는 뭐지?
DOM 이벤트 전파 방식의 2가지 단계이며, 이벤트 전파 방식의 순서는 다음과 같다.
캡처링 단계 → 타겟단계 → 버블링 단계
**1. 캡처링 단계**
이벤트가 DOM 트리의 최상위 요소부터 시작하여 이벤트가 발생한 요소까지 전달되는 방식
”캡처”하는 동작처럼 이벤트를 위에서 아래로 내려보냄
 동작방식
      1. 최상위 요소 (html)에서 이벤트 전파가 시작됨
     2. 자식 요소로 차례로 내려가며 이벤트를 전달함
     3. 이벤트가 발생한 요소에 도달함

**2. 타겟단계**
이벤트가 실제로 발생한 요소에서 실행됨
이벤트 리스너가 요소에 등록되어 있다면 캡처 단계에서 실행되든 버블링에서 실행되든 관계없이 해당 요소의 이벤트가 동작함

**3. 버블링 단계** 
이벤트가 가장 구체적인 요소(이벤트 발생 요소)에서 시작하여 DOM 트리를 따라 점점 상위 요소로 전파되는 방식
동작 방식
     1. 이벤트가 발생한 요소 (buton 클릭 등)에서 시작됨
     2. 부모 요소를 차례로 거쳐 html 요소까지 전달됨
> 
> 
> ### **캡처링 vs 버블링 비교**
> 
> | 특징 | 캡처링 (Event Capturing) | 버블링 (Event Bubbling) |
> | --- | --- | --- |
> | 전파 방향 | 상위 요소 → 하위 요소 | 하위 요소 → 상위 요소 |
> | 설정 방법 | `addEventListener`의 세 번째 인자에 `true` | 기본 동작 (세 번째 인자에 `false` 또는 생략) |
> | 활용 사례 | 이벤트를 먼저 처리해야 하는 경우 | 기본적으로 많이 사용됨 |

- 리액트는 브라우저 이벤트를 합성한 합성 이벤트 또한 제공한다.
- 예를 들어 `React.EventHandler<ChangeEvent<HTMLSelectElement>>` 의 경우, select 엘리먼트의 change 이벤트를 감지하여 처리하는 이벤트 핸들러인 것이다.
- 훅이나 외부 라이브러리, 내부 모듈의 함수 등은 적절한 제네릭 타입을 통해 다른 타입의 입력 등을 막는 식으로 타입을 제한하여 활용할 수 있다.
- 제네릭 컴포넌트 만들기 → ?
- `ComponentPropsWithoutRef` 을 사용하면 리액트 컴포넌트의 prop 타입을 반환하여 더 정확한 타입을 설정할 수 있다.
- CSS-in-JS : 리액트 컴포넌트를 만들 때 CSS 파일 대신 자바 스크립트 안에 직접 스타일을 정의
- (스타일드 컴포넌트  다시 읽어보기)
- 공변성 : 타입 A 가 타입 B의 서브 타입일 때 T<A> 가 T<B>의 서브 타입이 된다 (더 좁은 타입이면서 서브 타입인 경우)
- 반 공변성 : T<B>가 T<A>의 서브 타입이 되어 좁은 타입 T<A>의 함수를 넓은 함수 T<B>의 함수에 적용할 수 없다는 의미. 제네릭 타입을 지닌 함수는 반공변성을 띈다.
- -- strict 모드에서 함수 타입을 화살표 표기법으로 작성하게 된다면 반 공변성을 띄게 된다. 이와 달리 콜론으로 함수 타입을 지정하게 되면 공변성과 반 공변성을 모두 가지는 이변성을 가지게 된다. 일반적으로 안전한 타입 가드를 위해서 반 공변적인 함수 타입을 설정하는 것이 권장 된다.
