# 8.1 리액트 컴포넌트의 타입

> 이 절에서는 헷갈릴 수 있는 대표적인 리액트 컴포넌트 타입을 살펴보면서 상황에 따라 어떤 것을 사용하면 좋을지 그리고 사용할 때의 유의점은 무엇인지 알아보자.

1. 클래스 컴포넌트 타입

   ```tsx
   interface Component<P = {}, S = {}, SS = any>
     extends ComponentLifecycle<P, S, SS> {}

   class Component<P, S> {
     // 생략
   }

   class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}
   ```

   - 클래스 컴포넌트가 상속받는 React.Component 와 React.PureComponent의 타입 정의는 위와 같으며 P 와 S 는 각각 props 와 state 를 의미한다.
   - props 와 state 를 제네릭으로 받고 있다. 아래와 같이 사용할 수 있다.

   ```tsx
   // Welcome 컴포넌트의 props 타입 정의
   interface WelcomeProps {
     name: string;
   }

   class Welcome extends React.Component<WelcomeProps> {
     // 생략
   }
   ```

1. 함수 컴포넌트 타입

   ```tsx
   // 함수 선언을 사용한 방식
   function Welcome(props: WelcomeProps): JSX.Element {
     return <div>Hello, {props.name}!</div>;
   }

   // 함수 표현식을 사용한 방식 - React.FC 사용
   const Welcome: React.FC<WelcomeProps> = ({ name }) => {
     return <div>Hello, {name}!</div>;
   };

   // 함수 표현식을 사용한 방식 - React.VFC 사용
   const Welcome: React.VFC<WelcomeProps> = ({ name }) => {
     return <div>Hello, {name}!</div>;
   };

   // 함수 표현식을 사용한 방식 - JSX.Element를 반환 타입으로 지정
   const Welcome = ({ name }: WelcomeProps): JSX.Element => {
     return <div>Hello, {name}!</div>;
   };

   // React.FC 타입 정의
   type FC<P = {}> = FunctionComponent<P>;

   interface FunctionComponent<P = {}> {
     // props에 children을 추가
     (props: React.PropsWithChildren<P>, context?: any): React.ReactElement<
       any,
       any
     > | null;
     propTypes?: React.WeakValidationMap<P> | undefined;
     contextTypes?: React.ValidationMap<any> | undefined;
     defaultProps?: Partial<P> | undefined;
     displayName?: string | undefined;
   }

   // React.VFC 타입 정의
   type VFC<P = {}> = VoidFunctionComponent<P>;
   interface VoidFunctionComponent<P = {}> {
     // children 없음
     (props: P, context?: any): React.ReactElement<any, any> | null;
     propTypes?: React.WeakValidationMap<P> | undefined;
     contextTypes?: React.ValidationMap<any> | undefined;
     defaultProps?: Partial<P> | undefined;
     displayName?: string | undefined;
   }
   ```

   - 함수 컴포넌트를 선언할 때 많이 볼 수 있는 형태는 React.FC 혹은 React.VFC 로 타입을 지정하는 것이다.
   - 둘의 차이는 children 타입을 허용하는 지에 따라 다르다. React.FC 는 암묵적으로 children 을 포함하고 있기 때문에 해당 컴포넌트에서 children 을 사용하지 않더라도 허용한다. children 이 필요하지 않은 컴포넌트는 좀 더 명확하게 타입을 지정하기 위해 React.VFC 를 많이 사용한다.
   - ❗그러나!!! 리액트 v18로 넘어가면서 React.VFC 가 삭제되고 React.FC 에서 children 이 사라졌다!!

1. children props 타입 지정

   ```tsx
   type PropsWithChildren<P> = P & { children?: ReactNode | undefined };
   ```

   - 가장 보편적인 children 타입은 ReactNode | undefined 가 된다. ReactNode 는 ReactElement 외에도 boolean, number 등 여러 타입을 포함하는 타입이다. 더 구체적으로 타이핑하는 용도에는 적합하지 않다??

   ```tsx
   // Example 1
   type WelcomeProps = {
     children: "천생연분" | "더 귀한 분" | "귀한 분" | "고마운 분";
   };

   // Example 2
   type WelcomeProps = {
     children: string;
   };

   // Example 3
   type WelcomeProps = {
     children: React.ReactElement;
   };
   ```

   - ⭐ 아래 처럼 정의해서 사용하는 건가?

   ```tsx
   type WelcomeProps = {
     name: string;
     children: React.ReactElement;
   };

   const Welcome = ({ name, children }: WelcomeProps): JSX.Element => {
     return (
       <div>
         <h1>Hello, {name}!</h1>
         {children}
       </div>
     );
   };

   // 사용 예시
   <Welcome name="Alice">
     <p>This is a child component!</p>
   </Welcome>;
   ```

1. render 메서드와 함수 컴포넌트의 반환 타입 - React.ReactElement vs JSX.Element vs React.ReactNode

   - React.ReactElement, JSX.Element, React.ReactNode 3가지 타입에 대한 비교

   ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f3712c5b-02e6-4029-9dad-f633d7b71a99/1a8517f5-1996-4406-85ba-7a1bf9bd6f66/image.png)

   ### 1. React.ReactElement

   ```tsx
   interface ReactElement<
     P = any,
     T extends string | JSXElementConstructor<any> =
       | string
       | JSXElementConstructor<any>
   > {
     type: T;
     props: P;
     key: Key | null;
   }
   ```

   - 리액트는 실제 DOM 이 아니라 가상 DOM 을 기반으로 렌더링하는데 가상 DOM 의 엘러먼트는 ReactElement 형태로 저장된다. 즉 ReactElement 타입은 리액트 컴포넌트를 객체 형태로 저장하기 위한 포맷이다.

1. JSX.Element

```tsx
declare global {
  namespace JSX {
    interface Element extends React.ReactElement<any, any> {}
  }
}
```

- JSX.Element 타입은 ReactElement 를 확장하는 타입이다.
- ⭐ 코드를 확인해보면 declare global 로 글로벌 네임스페이스에 정의되어 있어 외부 라이브러리에서 해당 타입을 재정의하거나 확장할 수 있어, 유연성이 높다.

1. ReactNode

```tsx
type ReactText = string | number;

type ReactChild = ReactElement | ReactText;

type ReactFragment = {} | Iterable<ReactNode>;

type ReactNode =
  | ReactChild
  | ReactFragment
  | ReactPortal
  | boolean
  | null
  | undefined;
```

- ReactElement 외에도 boolean, string, number 등의 여러 타입을 포함하고 있다.

1. ReactElement, ReactNode, JSX.Element 활용하기

   - 3가지 모두 리액트의 요소를 나타내는 타입인데, 어째서 이렇게 많은 타입이 존재하는지 의문을 느낄 수 있다.
   - @types/react 패키지에 정의된 타입

   ```tsx
   declare namespace React {
     // ReactElement
     interface ReactElement<
       P = any,
       T extends string | JSXElementConstructor<any> =
         | string
         | JSXElementConstructor<any>
     > {
       type: T;
       props: P;
       key: Key | null;
     }

     // ReactNode
     type ReactText = string | number;

     type ReactChild = ReactElement | ReactText;

     type ReactFragment = {} | Iterable<ReactNode>;

     type ReactNode =
       | ReactChild
       | ReactFragment
       | ReactPortal
       | boolean
       | null
       | undefined;

     type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;
   }

   // JSX.Element
   declare global {
     namespace JSX {
       interface Element extends React.ReactElement<any, any> {}
     }
   }
   ```

   ### [ ReactElement ]

   ```tsx
   const element = React.createElement(
     "h1",
     { className: "greeting" },
     "Hello, world!"
   );

   // 주의: 다음 구조는 단순화되었다.
   const element = {
     type: "h1",
     props: {
       className: "greeting",
       children: "Hello, world!",
     },
   };

   // JSX 글로벌 네임스페이스 선언
   declare global {
     namespace JSX {
       interface Element extends React.ReactElement<any, any> {}
     }
   }
   ```

   - JSX 는 리액트 엘리먼트를 생성하기 위한 문법이며, 트랜스파일러는 JSX 문법을 createElement 메서드 호출문으로 위와 같은 리액트 엘리먼트를 생성한다.
   - 리액트는 위처럼 생긴 리액트 엘리멘트 객체를 읽어서 DOM 을 구성한다.
   - 즉, ReactElement 타입은 JSX의 createElement 메서드 호출로 생성된 리액트 엘리먼트를 나타내는 타입이다.

   ### [ ReactNode ]

   ```tsx
   type ReactText = string | number;

   type ReactChild = ReactElement | ReactText;

   type ReactFragment = {} | Iterable<ReactNode>;

   type ReactNode =
     | ReactChild
     | ReactFragment
     | ReactPortal
     | boolean
     | null
     | undefined;
   ```

   - ReactChild 타입은 ReactElement | string | number 로 정의되어 좀 더 넓은 범위를 가짐.
   - 그 외에도 boolean, null, undefined 등 훨씬 넓은 범주의 타입을 포함하고 있다.
   - 즉, ReactNode는 리액트의 render 함수가 반환할 수 있는 모든 형태를 담고 있다.

   ### [ JSX.Element ]

   ```tsx
   declare global {
     namespace JSX {
       interface Element extends React.ReactElement<any, any> {}
     }
   }
   ```

   - JSX.Element 는 ReactElement 의 제네릭으로 props 와 타입 필드에 대해 any 타입을 가지도록 확장한다.
   - 즉, ReactElement 의 특정 타입으로 props 와 타임 필드를 any 로 가지는 타입이다.
   - 단일 엘리먼트만 가능하다.

1. 사용 예시

   ### [ ReactNode ]

   - ReactNode 타입은 리액트의 render 함수가 반환할 수 모든 형태이기에, 리액트 컴포넌트가 가질 수 있는 모든 타입을 의미한다.
   - children 을 포함하는 props 타입을 선언하면 다음과 같다.

   ```tsx
   interface MyComponentProps {
     children?: React.ReactNode;
     // ...
   }
   ```

   - JSX 형태의 문법을 때로는 string, number, null, undefined 같이 어떤 타입이든 children prop 으로 지정할 수 있게 하고 싶다면 ReactNode 타입으로 children 을 선언하면 된다.
   - 👐 리액트 내장 타입인 PropsWithChidren 타입도 ReactNode 타입으로 children을 선언하고 있다.

   ```tsx
   type PropsWithChildren<P = unknown> = P & {
     children?: ReactNode | undefined;
   };

   interface MyProps {
     // ... 정의될 속성
   }

   type MyComponentProps = PropsWithChildren<MyProps>;
   ```

   - prop 으로 리액트 컴포넌트가 다양한 형태를 가질 수 있게 하고 싶을 때 유용함.

### [ JSX.Element ] ⁉️

- props 와 타입 필드가 any 인 리액트 엘리먼트를 의미한다.
- 단일 엘리먼트만 가능하다.
- 위의 특징 때문에 리액트 엘리먼트를 prop 으로 전달받아 render props 패턴으로 컴포넌트를 구현할 때 유용하게 활용할 수 있다. ← ❗ 이 부분이 잘 이해가 가지 않음. 덕분에 아래에 있는 말도 이해가 안감.

```tsx
interface Props {
  icon: JSX.Element;
}

const Item = ({ icon }: Props) => {
  // prop으로 받은 컴포넌트의 props에 접근할 수 있다
  const iconSize = icon.props.size;
  return <li>{icon}</li>;
};

// icon prop에는 JSX.Element 타입을 가진 요소만 할당할 수 있다
const App = () => {
  return <Item icon={<Icon size={14} />} />;
};
```

- JSX.Elemnet 타입으로 선언함으로서 해당 prop에는 JSX 문법만 삽입할 수 있다. → 어째서?? any라며
- 또한 icon.props 에 접근하여 prop으로 넘겨받은 컴포넌트의 상세한 데이터를 가져올 수 있다.

### [ ReactElement ]

- JSX.Element 예시를 확장하여 **추론 관점에서 더 유용**하게 활용할 수 있는 방법은 JSX.Element 대신 ReactElement 를 사용하는 것이다. 이 때 원하는 컴포넌트의 props 를 ReactElement 의 제네릭으로 지정해줄 수 있음.
- JSX.Element 가 ReactElement 의 props 타입으로 any 가 지정되었다면,

```tsx
interface IconProps {
  size: number;
}

interface Props {
  // ReactElement의 props 타입으로 IconProps 타입 지정
  icon: React.ReactElement<IconProps>;
}

const Item = ({ icon }: Props) => {
  // icon prop으로 받은 컴포넌트의 props에 접근하면, props의 목록이 추론된다
  const iconSize = icon.props.size;

  return <li>{icon}</li>;
};
```

- 이걸 사용하면 어떤 props 가 있는지 추론할 수 있는 것처럼 보인다.

1. 리액트에서 기본 HTML 요소 타입 활용하기

   ```tsx
   const SquareButton = () => <button> 정사각형 버튼 <button>;
   ```

   새롭게 만든 Button 컴포넌트는 기존 HTML button 과 같은 역할을 하면서도 새로운 기능이나 UI 가 추가된 형태이다. 기존 button 태그가 onClick 이벤트를 지원하는 것처럼 새로운 Button 컴포넌트도 onClick 이벤트 핸들러를 지원해야만 한다.

   HTML 태그의 속성 타입을 활용하여 타입을 지정하는 방법

   ### [ DetailedHTMLProps 와 ComponentWithoutRef ]

   ```tsx
   // React.DetailedHTMLProps를 활용한 타입 선언
   type NativeButtonProps = React.DetailedHTMLProps<
     React.ButtonHTMLAttributes<HTMLButtonElement>,
     HTMLButtonElement
   >;

   type ButtonProps = {
     onClick?: NativeButtonProps["onClick"];
   };
   ```

   - `React.DetailedHTMLProps`는 HTML 태그와 관련된 속성들의 타입을 지정할 때 사용됩니다.
   - `React.DetailedHTMLProps<T, E>`는 두 가지 제네릭 인자를 받습니다:
     - `T`: 속성 타입(예: `React.ButtonHTMLAttributes`).
     - `E`: 요소 타입(예: `HTMLButtonElement`).

   ```tsx
   // React.ComponentPropsWithoutRef를 활용한 타입 선언
   type NativeButtonType = React.ComponentPropsWithoutRef<"button">;

   type ButtonPropsWithoutRef = {
     onClick?: NativeButtonType["onClick"];
   };
   ```

   - `React.ComponentPropsWithoutRef<"button">`는 HTML `<button>` 태그와 관련된 속성들의 타입을 추론하는 데 사용됩니다.
   - 이는 `React.DetailedHTMLProps`와 비슷하지만, 참조(`ref`)를 포함하지 않는 타입을 정의합니다.

   ### [ 언제 ComponentPropsWithoutRef를 사용하면 좋을까? ]

   **결론부터 이야기하면!!!** HTML 속성을 확장하는 props 를 설계할 때는 ComponentPropsWithoutRef 타입을 사용하여 ref 가 실제로 forwardRef 와 함께 사용될 때만 props 로 전달 받도록 타입을 정의하는 것이 안전하다.

   - ⭐ ref 란? 생성된 DOM 노드나 리액트 엘리먼트에 접근하는 방법.
